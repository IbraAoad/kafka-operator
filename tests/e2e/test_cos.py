# Copyright 2023 Canonical Ltd.
# See LICENSE file for licensing details.

"""Metrics and logs from a machine charm are ingested over juju-info/cos_agent by COS Lite."""

import asyncio
import logging
import os
import subprocess
from types import SimpleNamespace

import pytest
from helpers import get_or_add_model, ZK_NAME, APP_NAME
from juju.controller import Controller
from pytest_operator.plugin import OpsTest

logger = logging.getLogger(__name__)

agent = SimpleNamespace(charm="grafana-agent", name="agent")


@pytest.mark.abort_on_fail
async def test_setup_models(ops_test: OpsTest):
    global lxd_mdl, k8s_mdl, k8s_ctl

    # print(os.environ)
    # lxd_ctl_name = os.environ["LXD_CONTROLLER"]
    # k8s_ctl_name = os.environ["K8S_CONTROLLER"]
    
    lxd_ctl_name = "vms"
    k8s_ctl_name = "micro"

    # The current model name is generated by pytest-operator from the test name + random suffix.
    # Use the same model name in both controllers.
    k8s_mdl_name = lxd_mdl_name = ops_test.model_name

    # We do not want to make assumptions here about the current controller.
    # Assuming a k8s controller is ready and its name is stored in $LXD_CONTROLLER.
    lxd_ctl = Controller()
    await lxd_ctl.connect(lxd_ctl_name)
    lxd_mdl = await get_or_add_model(ops_test, lxd_ctl, lxd_mdl_name)
    await lxd_mdl.set_config({"logging-config": "<root>=WARNING; unit=DEBUG"})

    # Assuming a k8s controller is ready and its name is stored in $K8S_CONTROLLER.
    k8s_ctl = Controller()
    await k8s_ctl.connect(k8s_ctl_name)
    k8s_mdl = await get_or_add_model(ops_test, k8s_ctl, k8s_mdl_name)
    await k8s_mdl.set_config({"logging-config": "<root>=WARNING; unit=DEBUG"})


@pytest.mark.skip
@pytest.mark.abort_on_fail
async def test_deploy_cos():
    # Use CLI to deploy bundle until https://github.com/juju/python-libjuju/issues/816 is fixed.
    # await k8s_mdl.deploy(str(rendered_bundle), trust=True)
    cmd = [
        "juju",
        "deploy",
        "--trust",
        "-m",
        f"{k8s_ctl.controller_name}:{k8s_mdl.name}",
        "cos-lite",
        "--overlay",
        "./tests/e2e/overlays/offers-overlay.yaml",
    ]
    try:
        subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        logger.error(e.output.decode())
        raise


@pytest.mark.abort_on_fail
async def test_build_and_deploy_machine_charms(ops_test: OpsTest, kafka_charm):
    await asyncio.gather(
        lxd_mdl.deploy(
            ZK_NAME, channel="edge", application_name=ZK_NAME, num_units=1, series="jammy"
        ),
        lxd_mdl.deploy(kafka_charm, application_name=APP_NAME, num_units=1, series="jammy"),
        lxd_mdl.deploy(
            agent.charm,
            application_name=agent.name,
            num_units=0,
            series="jammy",
            channel="edge",
        ),
    )
    await lxd_mdl.wait_for_idle(apps=[APP_NAME, ZK_NAME], idle_period=30, timeout=3600)
    assert lxd_mdl.applications[APP_NAME].status == "blocked"
    assert lxd_mdl.applications[ZK_NAME].status == "active"

    await asyncio.gather(
        lxd_mdl.add_relation(APP_NAME, ZK_NAME),
        lxd_mdl.wait_for_idle(apps=[APP_NAME, ZK_NAME], idle_period=30),
    )
    assert lxd_mdl.applications[APP_NAME].status == "active"
    assert lxd_mdl.applications[ZK_NAME].status == "active"
    
    await asyncio.gather(
        lxd_mdl.add_relation(f"kafka:cos-agent", agent.name),
        lxd_mdl.block_until(lambda: len(lxd_mdl.applications[agent.name].units) > 0),
    )

@pytest.mark.skip
@pytest.mark.abort_on_fail
async def test_integration():
    # The consumed endpoint names must match offers-overlay.yaml.
    await asyncio.gather(
        lxd_mdl.consume(
            f"admin/{k8s_mdl.name}.prometheus-receive-remote-write",
            application_alias="prometheus",
            controller_name=k8s_ctl.controller_name,  # same as os.environ["K8S_CONTROLLER"]
        ),
        lxd_mdl.consume(
            f"admin/{k8s_mdl.name}.loki-logging",
            application_alias="loki",
            controller_name=k8s_ctl.controller_name,  # same as os.environ["K8S_CONTROLLER"]
        ),
        lxd_mdl.consume(
            f"admin/{k8s_mdl.name}.grafana-dashboards",
            application_alias="grafana",
            controller_name=k8s_ctl.controller_name,  # same as os.environ["K8S_CONTROLLER"]
        ),
    )

    await asyncio.gather(
        lxd_mdl.add_relation(agent.name, "prometheus"),
        lxd_mdl.add_relation(agent.name, "loki"),
        lxd_mdl.add_relation(agent.name, "grafana"),
    )

    # `idle_period` needs to be greater than the scrape interval to make sure metrics ingested.
    await asyncio.gather(
        lxd_mdl.wait_for_idle(
            status="active", timeout=7200, idle_period=180, raise_on_error=False
        ),
        k8s_mdl.wait_for_idle(
            status="active", timeout=7200, idle_period=180, raise_on_error=False
        ),
    )